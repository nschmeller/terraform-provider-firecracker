// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/warehouse-13/hammertime/pkg/client"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ datasource.DataSource              = &vmsDataSource{}
	_ datasource.DataSourceWithConfigure = &vmsDataSource{}
)

func NewVMsDataSource() datasource.DataSource {
	return &vmsDataSource{}
}

// vmsDataSource defines the data source implementation.
type vmsDataSource struct {
	client *client.Client
}

// VMsDataSourceModel describes the data source data model.
// This type and its underlying types are adapted from
// https://buf.build/weaveworks-liquidmetal/flintlock/docs/main:microvm.services.api.v1alpha1#microvm.services.api.v1alpha1.MicroVM.ListMicroVMs
// TODO: pipe the code autogenerated by the Go gRPC protocol buffer
// compiler into a template to automatically generate these types
type VMsDataSourceModel struct {
	VMs []vmModel `tfsdk:"vms"`
}

// vmModel represents a microvm machine that is created via a provider.
// This type and its underlying types are adapted from
// https://buf.build/weaveworks-liquidmetal/flintlock/docs/58fe9b39fd874ce7abc0773abe71f072:flintlock.types#flintlock.types.MicroVM
type vmModel struct {
	// version types.Int64 `tfsdk:"version"`
	// Spec is the specification of the microvm.
	Spec vmSpecModel `tfsdk:"spec"`
	// Status is the runtime status of the microvm.
	Status vmStatusModel `tfsdk:"status"`
}

// vmSpecModel represents the specification for a microvm.
// This type and its underlying types are adapted from
// https://buf.build/weaveworks-liquidmetal/flintlock/docs/58fe9b39fd874ce7abc0773abe71f072:flintlock.types#flintlock.types.MicroVMSpec
type vmSpecModel struct {
	// ID is the identifier of the microvm.
	// If this empty at creation time a ID will be automatically generated.
	ID types.String `tfsdk:"id"`
	// Namespace is the name of the namespace the microvm belongs to.
	Namespace types.String `tfsdk:"namespace"`
	// Labels allows you to include extra data for the microvms.
	Labels types.Object `tfsdk:"labels"`
	// VCPU specifies how many vcpu the machine will be allocated.
	VCPU types.Int64 `tfsdk:"vcpu"`
	// MemoryInMb is the amount of memory in megabytes that the machine will be allocated.
	MemoryInMB types.Int64 `tfsdk:"memory_in_mb"`
	// Kernel is the details of the kernel to use.
	Kernel kernelModel `tfsdk:"kernel"`
	// Initrd is the optional details of the initial ramdisk.
	Initrd initrdModel `tfsdk:"initrd"`
	// RootVolume specifies the root volume mount for the MicroVM.
	RootVolume volumeModel `tfsdk:"root_volume"`
	// AdditionalVolumes specifies the volumes to be attached to the microvm.
	AdditionalVolumes []volumeModel `tfsdk:"additional_volumes"`
	// Interfaces specifies the network interfaces to be attached to the microvm.
	// Device names on the guest machine are determined by the order defined in
	// the list starting from eth1, eth2, ..., ethN.
	Interfaces []networkInterfaceModel `tfsdk:"interfaces"`
	// Metadata allows you to specify data to be added to the metadata service. The key is the name
	// of the metadata item and the value is the base64 encoded contents of the metadata.
	Metadata types.Object `tfsdk:"metadata"`
	// CreatedAt indicates the time the microvm was created at.
	CreatedAt types.Int64 `tfsdk:"created_at"`
	// UpdatedAt indicates the time the microvm was last updated.
	UpdatedAt types.Int64 `tfsdk:"updated_at"`
	// DeletedAt indicates the time the microvm was marked as deleted.
	DeletedAt types.Int64 `tfsdk:"deleted_at"`
	// UID is a globally unique identifier of the microvm.
	UID types.String `tfsdk:"uid"`
}

// kernelModel represents the configuration for a kernel.
// This type is adapted from
// https://buf.build/weaveworks-liquidmetal/flintlock/docs/58fe9b39fd874ce7abc0773abe71f072:flintlock.types#flintlock.types.Kernel
type kernelModel struct {
	// Image is the container image to use.
	Image types.String `tfsdk:"image"`
	// Cmdline is the additional kernel command line args. Each provider has its
	// own recommended list, they will be used automatically. This field is for
	// additional values.
	Cmdline types.Object `tfsdk:"cmdline"`
	// Filename is used to specify the name of the kernel file
	// in the Image.
	Filename types.String `tfsdk:"filename"`
	// AddNetworkConfig if set to true indicates that the network-config kernel argument should be generated.
	AddNetworkConfig types.Bool `tfsdk:"add_network_config"`
}

// initrdModel represents the configuration for the initial ramdisk.
// This type is adapted from
// https://buf.build/weaveworks-liquidmetal/flintlock/docs/58fe9b39fd874ce7abc0773abe71f072:flintlock.types#flintlock.types.Initrd
type initrdModel struct {
	// Image is the container image to use.
	Image types.String `tfsdk:"image"`
	// Filename is used to specify the name of the kernel file
	// in the Image. Defaults to initrd
	Filename types.String `tfsdk:"filename"`
}

// volumeModel represents the configuration for a volume to be attached to a microvm.
// This type and its underlying types are adapted from
// https://buf.build/weaveworks-liquidmetal/flintlock/docs/58fe9b39fd874ce7abc0773abe71f072:flintlock.types#flintlock.types.Volume
type volumeModel struct {
	// ID is the unique identifier of the volume.
	ID types.String `tfsdk:"id"`
	// IsReadOnly specifies that the volume is to be mounted readonly.
	IsReadOnly types.Bool `tfsdk:"is_read_only"`
	// MountPoint allows you to optionally specify a mount point for the volume. This only
	// applied to additional volumes and it will use cloud-init to mount the volumes.
	MountPoint types.String `tfsdk:"mount_point"`
	// Source is where the volume will be sourced from.
	Source volumeSourceModel `tfsdk:"source"`
	// PartitionID is the uuid of the boot partition.
	PartitionID types.String `tfsdk:"partition_id"`
	// SizeInMB is the size to resize this volume to.
	SizeInMB types.Int64 `tfsdk:"size_in_mb"`
}

// volumeSourceModel is the source of a volume. Based loosely on the volumes in Kubernetes Pod specs.
// This type is adapted from
// https://buf.build/weaveworks-liquidmetal/flintlock/docs/58fe9b39fd874ce7abc0773abe71f072:flintlock.types#flintlock.types.VolumeSource
type volumeSourceModel struct {
	// Container is used to specify a source of a volume as a OCI container.
	Container types.String `tfsdk:"container_source"`
}

// networkInterfaceModel represents a network interface in the microvm.
// This type and its underlying types are adapted from
// https://buf.build/weaveworks-liquidmetal/flintlock/docs/58fe9b39fd874ce7abc0773abe71f072:flintlock.types#flintlock.types.NetworkInterface
type networkInterfaceModel struct {
	// DeviceID is the ID of the interface. There is no relation between the ID
	// and the name of the interface device on the quest machine.
	DeviceID types.String `tfsdk:"device_id"`
	// IfaceType specifies the type of network interface to create for use by the guest.
	IfaceType types.String `tfsdk:"type"`
	// GuestMAC allows the specifying of a specifi MAC address to use for the interface. If
	// not supplied a autogenerated MAC address will be used.
	GuestMAC types.String `tfsdk:"guest_mac"`
	// Address is an optional static IP address to manually assign to this interface.
	// If not supplied then DHCP will be used.
	Address staticAddressModel `tfsdk:"address"`
	// Overrides is optional overrides applicable for network configuration.
	Overrides networkOverridesModel `tfsdk:"overrides"`
}

// staticAddressModel represents a static IPv4 or IPv6 address.
// This type is adapted from
// https://buf.build/weaveworks-liquidmetal/flintlock/docs/58fe9b39fd874ce7abc0773abe71f072:flintlock.types#flintlock.types.StaticAddress
type staticAddressModel struct {
	// Address is the static IP address (IPv4 or IPv6) to assign to this interface.
	// Must be CIDR notation.
	Address types.String `tfsdk:"address"`
	// Gateway is used to optionaly set the default gateway for IPv4 or IPv6.
	Gateway types.String `tfsdk:"gateway"`
	// Nameservers allows you to optionally specify nameservers for the interface.
	Nameservers []types.String `tfsdk:"nameservers"`
}

// networkOverridesModel represents override values for a network interface.
// This type is adapted from
// https://buf.build/weaveworks-liquidmetal/flintlock/docs/58fe9b39fd874ce7abc0773abe71f072:flintlock.types#flintlock.types.NetworkOverrides
type networkOverridesModel struct {
	// BridgeName is the name of the Linux bridge to attach TAP devices to. This overrides
	// any value set at the overall flintlock level.
	BridgeName types.String `tfsdk:"bridge_name"`
}

// vmStatusModel contains the runtime status of the microvm.
// This type and its underlying types are adapted from
// https://buf.build/weaveworks-liquidmetal/flintlock/docs/58fe9b39fd874ce7abc0773abe71f072:flintlock.types#flintlock.types.MicroVMStatus
type vmStatusModel struct {
	// State stores information about the last known state of the vm and the spec.
	State types.String `tfsdk:"state"`
	// Volumes holds the status of the volumes.
	Volumes types.ObjectType `tfsdk:"volumes"` // TODO use map[string]volumeStatusModel
	// KernelMount holds the status of the kernel mount point.
	KernelMount mountModel `tfsdk:"kernel_mount"`
	// InitrdMount holds the status of the initrd mount point.
	InitrdMount mountModel `tfsdk:"initrd_mount"`
	// NetworkInterfaces holds the status of the network interfaces.
	NetworkInterfaces types.ObjectType `tfsdk:"network_interfaces"` // TODO use map[string]networkInterfaceModel
	// Retry is a counter about how many times we retried to reconcile.
	Retry types.Int64 `tfsdk:"retry"`
}

// // volumeStatusModel represents the status of a volume in the microvm.
// // This type is adapted from
// // https://buf.build/weaveworks-liquidmetal/flintlock/docs/58fe9b39fd874ce7abc0773abe71f072:flintlock.types#flintlock.types.VolumeStatus
// type volumeStatusModel struct {
// 	// Mount represents a volume mount point.
// 	Mount mountModel `tfsdk:"mount"`
// }

// mountModel represents a volume mount point.
// This type is adapted from
// https://buf.build/weaveworks-liquidmetal/flintlock/docs/58fe9b39fd874ce7abc0773abe71f072:flintlock.types#flintlock.types.Mount
type mountModel struct {
	// Type specifies the type of the mount (e.g. device or directory).
	Type types.String `tfsdk:"type"`
	// Source is the location of the mounted volume.
	Source types.String `tfsdk:"source"`
}

// // networkInterfaceStatusModel represents the status of a network interface on the microvm.
// // This type is adapted from
// // https://buf.build/weaveworks-liquidmetal/flintlock/docs/58fe9b39fd874ce7abc0773abe71f072:flintlock.types#flintlock.types.NetworkInterfaceStatus
// type networkInterfaceStatusModel struct {
// 	// HostDeviceName is the name of the network interface used from the host. This will be
// 	// a tuntap or macvtap interface.
// 	HostDeviceName types.String `tfsdk:"host_device_name"`
// 	// Index is the index of the network interface on the host.
// 	Index types.Int64 `tfsdk:"index"`
// 	// MACAddress is the MAC address of the host interface.
// 	MACAddress types.String `tfsdk:"mac_address"`
// }

func (d *vmsDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_vms"
}

func (d *vmsDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Data source representing the managed Firecracker microVMs",
		Attributes: map[string]schema.Attribute{
			"vms": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"spec": schema.MapNestedAttribute{
							Computed:    true,
							Description: "Spec is the specification of the microvm.",
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"id": schema.StringAttribute{
										Computed:    true,
										Description: "ID is the identifier of the microvm. If empty at creation time a ID will be automatically generated.",
									},
									"namespace": schema.StringAttribute{
										Computed:    true,
										Description: "Namespace is the name of the namespace the microvm belongs to.",
									},
									"label": schema.MapAttribute{
										Computed:    true,
										Description: "Labels allows you to include extra data for the microvms.",
										ElementType: types.StringType,
									},
									"vcpu": schema.Int64Attribute{
										Computed:    true,
										Description: "VCPU specifies how many vcpu the machine will be allocated.",
									},
									"memory_in_mb": schema.Int64Attribute{
										Computed:    true,
										Description: "MemoryInMb is the amount of memory in megabytes that the machine will be allocated.",
									},
									"kernel": schema.MapNestedAttribute{
										Computed:    true,
										Description: "Kernel is the details of the kernel to use.",
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"image": schema.StringAttribute{
													Computed:    true,
													Description: "Image is the container image to use.",
												},
												"cmdline": schema.MapAttribute{
													Computed:    true,
													Description: "Cmdline is the additional kernel command line args. Each provider has its own recommended list, they will be used automatically. This field is for additional values.",
													ElementType: types.StringType,
												},
												"filename": schema.StringAttribute{
													Computed:    true,
													Description: "Filename is used to specify the name of the kernel file in the Image.",
												},
												"add_network_config": schema.BoolAttribute{
													Computed:    true,
													Description: "AddNetworkConfig if set to true indicates that the network-config kernel argument should be generated.",
												},
											},
										},
									},
									"initrd": schema.MapNestedAttribute{
										Computed:    true,
										Description: "Initrd is the optional details of the initial ramdisk.",
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"image": schema.StringAttribute{
													Computed:    true,
													Description: "Image is the container image to use.",
												},
												"filename": schema.StringAttribute{
													Computed:    true,
													Description: "Filename is used to specify the name of the kernel file in the Image. Defaults to initrd",
												},
											},
										},
									},
									"root_volume": schema.MapNestedAttribute{
										Computed:    true,
										Description: "RootVolume specifies the root volume mount for the MicroVM.",
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"id": schema.StringAttribute{
													Computed:    true,
													Description: "ID is the unique identifier of the volume.",
												},
												"is_read_only": schema.BoolAttribute{
													Computed:    true,
													Description: "IsReadOnly specifies that the volume is to be mounted readonly.",
												},
												"mount_point": schema.StringAttribute{
													Computed:    true,
													Description: "MountPoint allows you to optionally specify a mount point for the volume. This only applied to additional volumes and it will use cloud-init to mount the volumes.",
												},
												"source": schema.MapNestedAttribute{
													Computed:    true,
													Description: "Source is where the volume will be sourced from.",
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"container_source": schema.StringAttribute{
																Computed:    true,
																Description: "Container is used to specify a source of a volume as a OCI container.",
															},
														},
													},
												},
												"partition_id": schema.StringAttribute{
													Computed:    true,
													Description: "PartitionID is the uuid of the boot partition.",
												},
												"size_in_mb": schema.Int64Attribute{
													Computed:    true,
													Description: "SizeInMB is the size to resize this volume to.",
												},
											},
										},
									},
									"additional_volumes": schema.ListNestedAttribute{
										Computed:    true,
										Description: "AdditionalVolumes specifies the volumes to be attached to the microvm.",
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"id": schema.StringAttribute{
													Computed:    true,
													Description: "ID is the unique identifier of the volume.",
												},
												"is_read_only": schema.BoolAttribute{
													Computed:    true,
													Description: "IsReadOnly specifies that the volume is to be mounted readonly.",
												},
												"mount_point": schema.StringAttribute{
													Computed:    true,
													Description: "MountPoint allows you to optionally specify a mount point for the volume. This only applied to additional volumes and it will use cloud-init to mount the volumes.",
												},
												"source": schema.MapNestedAttribute{
													Computed:    true,
													Description: "Source is where the volume will be sourced from.",
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"container_source": schema.StringAttribute{
																Computed:    true,
																Description: "Container is used to specify a source of a volume as a OCI container.",
															},
														},
													},
												},
												"partition_id": schema.StringAttribute{
													Computed:    true,
													Description: "PartitionID is the uuid of the boot partition.",
												},
												"size_in_mb": schema.Int64Attribute{
													Computed:    true,
													Description: "SizeInMB is the size to resize this volume to.",
												},
											},
										},
									},
									"interfaces": schema.ListNestedAttribute{
										Computed:    true,
										Description: "Interfaces specifies the network interfaces to be attached to the microvm. Device names on the guest machine are determined by the order defined in the list starting from eth1, eth2, ..., ethN.",
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"device_id": schema.StringAttribute{
													Computed:    true,
													Description: "DeviceID is the ID of the interface. There is no relation between the ID and the name of the interface device on the quest machine.",
												},
												"type": schema.StringAttribute{
													Computed:    true,
													Description: "IfaceType specifies the type of network interface to create for use by the guest.",
												},
												"guest_mac": schema.StringAttribute{
													Computed:    true,
													Description: "GuestMAC allows the specifying of a specific MAC address to use for the interface. If not supplied a autogenerated MAC address will be used.",
												},
												"address": schema.MapNestedAttribute{
													Computed:    true,
													Description: "Address is an optional static IP address to manually assign to this interface. If not supplied then DHCP will be used.",
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"address": schema.StringAttribute{
																Computed:    true,
																Description: "Address is the static IP address (IPv4 or IPv6) to assign to this interface. Must be CIDR notation.",
															},
															"gateway": schema.StringAttribute{
																Computed:    true,
																Description: "Gateway is used to optionaly set the default gateway for IPv4 or IPv6.",
															},
															"nameservers": schema.ListAttribute{
																Computed:    true,
																Description: "Nameservers allows you to optionally specify nameservers for the interface.",
																ElementType: types.StringType,
															},
														},
													},
												},
												"overrides": schema.MapNestedAttribute{
													Computed:    true,
													Description: "Overrides is optional overrides applicable for network configuration.",
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"bridge_name": schema.StringAttribute{
																Computed:    true,
																Description: "BridgeName is the name of the Linux bridge to attach TAP devices to. This overrides any value set at the overall flintlock level.",
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						"status": schema.MapNestedAttribute{
							Computed:    true,
							Description: "Status is the runtime status of the microvm.",
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"state": schema.StringAttribute{
										Computed:    true,
										Description: "State stores information about the last known state of the vm and the spec.",
									},
									"volumes": schema.MapAttribute{
										Computed:    true,
										Description: "Volumes holds the status of the volumes.",
										ElementType: types.ObjectType{
											AttrTypes: map[string]attr.Type{
												"mount": types.ObjectType{
													AttrTypes: map[string]attr.Type{
														"type": types.StringType,
													},
												},
											},
										},
									},
									"kernel_mount": schema.MapNestedAttribute{
										Computed:    true,
										Description: "KernelMount holds the status of the kernel mount point.",
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"type": schema.StringAttribute{
													Computed:    true,
													Description: "Type specifies the type of the mount (e.g. device or directory).",
												},
												"source": schema.StringAttribute{
													Computed:    true,
													Description: "Source is the location of the mounted volume.",
												},
											},
										},
									},
									"initrd_mount": schema.MapNestedAttribute{
										Computed:    true,
										Description: "InitrdMount holds the status of the initrd mount point.",
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"type": schema.StringAttribute{
													Computed:    true,
													Description: "Type specifies the type of the mount (e.g. device or directory).",
												},
												"source": schema.StringAttribute{
													Computed:    true,
													Description: "Source is the location of the mounted volume.",
												},
											},
										},
									},
									"network_interfaces": schema.MapAttribute{
										Computed:    true,
										Description: "NetworkInterfaces holds the status of the network interfaces.",
										ElementType: types.ObjectType{
											AttrTypes: map[string]attr.Type{
												"device_id": types.StringType,
												"type":      types.StringType,
												"guest_mac": types.StringType,
												"address": types.ObjectType{
													AttrTypes: map[string]attr.Type{
														"address": types.StringType,
														"gateway": types.StringType,
														"nameservers": types.ListType{
															ElemType: types.StringType,
														},
													},
												},
												"overrides": types.ObjectType{
													AttrTypes: map[string]attr.Type{
														"bridge_name": types.StringType,
													},
												},
											},
										},
									},
									"retry": schema.Int64Attribute{
										Computed:    true,
										Description: "Retry is a counter about how many times we retried to reconcile.",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func (d *vmsDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Data Source Configure Type",
			fmt.Sprintf("Expected %T, got: %T. Please report this issue to the provider developers.", d.client, req.ProviderData),
		)

		return
	}

	d.client = client
}

// TODO pick up at https://developer.hashicorp.com/terraform/tutorials/providers-plugin-framework/providers-plugin-framework-data-source-read#implement-read-functionality
func (d *vmsDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data VMsDataSourceModel

	// Read Terraform configuration data into the model
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// httpResp, err := d.client.Do(httpReq)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read example, got error: %s", err))
	//     return
	// }

	// For the purposes of this example code, hardcoding a response value to
	// save into the Terraform state.
	// data.Id = types.StringValue("example-id")

	// Write logs using the tflog package
	// Documentation: https://terraform.io/plugin/log
	tflog.Trace(ctx, "read a data source")

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
